# Документация `snap-off`: 2. Анатомия компонента

Компонент в `snap-off` — это фундаментальная единица кода, объединяющая в себе HTML-представление, серверную логику и стили. Философия `snap-off` требует строгой и предсказуемой структуры, которая обеспечивает порядок в проекте и легкость поддержки.

Каждый компонент представляет собой директорию внутри папки `src/components/`. Имя директории является уникальным именем компонента.

## 2.1. Структура файлов

Рассмотрим каноническую структуру на примере компонента `my-component`:

```
src/
└── components/
    └── my-component/
        ├── component.json        // (Обязательно) Паспорт компонента
        ├── handler.js            // (Обязательно) Серверная логика
        ├── view.html             // (Обязательно) HTML-шаблон
        ├── style.css             // (Опционально) Изолированные стили
        └── component.stories.js  // (Опционально) Сценарии для Dev Lab
```

Давайте подробно разберем назначение каждого файла.

### `component.json` (Паспорт)

Это небольшой JSON-файл, содержащий мета-информацию о компоненте. Он используется Dev Lab и может быть полезен для автоматической генерации документации.

**Пример:**
```json
{
  "name": "Кнопка с иконкой",
  "description": "Универсальная кнопка, которая может отображать текст и иконку.",
  "version": "1.0.0"
}
```

### `handler.js` (Мозг)

Это сердце вашего компонента. ES-модуль, который экспортирует две ключевые сущности: `createState` и `events`. **Вся логика выполняется исключительно на сервере.**

*   **`createState(props)`**: Обязательная функция. Она вызывается при первом рендере компонента для создания его начального состояния.
    -   `props` (объект): Аргументы, переданные в `snap.render('my-component', props, req)`.
    -   **Возвращает:** Объект, представляющий начальное состояние компонента. Это состояние будет сохранено в сессии пользователя.

*   **`events`**: Необязательный объект. Он содержит функции-обработчики для событий, инициированных пользователем.
    -   Каждый ключ объекта — это имя события (например, `increment`).
    -   Каждое значение — это функция, принимающая `(state, payload)` и **возвращающая новый объект состояния**.
        -   `state`: Текущее состояние компонента.
        -   `payload`: Данные, отправленные клиентом (например, из формы).

**Пример (`handler.js` для счетчика):**
```javascript
// Определяет начальное состояние.
export function createState(props) {
  return { 
    count: props.initialValue || 0,
    message: "Готов к работе"
  };
}

// Определяет, как состояние меняется в ответ на события.
export const events = {
  increment: (state, payload) => {
    // Важно: всегда возвращаем новый объект, а не мутируем старый!
    return { 
      ...state, 
      count: state.count + 1,
      message: "Значение увеличено"
    };
  },
  decrement: (state) => {
    return { 
      ...state, 
      count: state.count - 1,
      message: "Значение уменьшено"
    };
  }
};
```

### `view.html` (Лицо)

Это HTML-шаблон компонента, использующий синтаксис **Handlebars**. Внутри шаблона вам доступны несколько специальных объектов:

*   **`{{state}}`**: Текущий объект состояния компонента. (например, `{{state.count}}`)
*   **`{{props}}`**: Объект "чистых" HTML-атрибутов, переданных в компонент.
*   **`{{meta}}`**: Объект метаданных, содержащий:
    -   `{{meta.id}}`: Уникальный ID **экземпляра** этого компонента. Критически важен для HTMX-запросов.
    -   `{{meta.name}}`: Имя компонента (имя папки).
    -   Все поля из `component.json`.
*   **`{{{styleAttr}}}`**: Готовая строка атрибута `style="..."` для инлайн-стилизации через пропсы. (Используйте тройные скобки!)
*   **`{{{styleTag}}}`**: Готовый тег `<style>...</style>` с изолированными CSS-правилами. (Используйте тройные скобки!)

**Пример (`view.html` для счетчика):**
```html
<div class="counter-root" snap-c-id="{{meta.id}}" {{{styleAttr}}}>
  <p>Счетчик: {{state.count}}</p>
  <p>Сообщение: <i>{{state.message}}</i></p>
  
  <!--
    hx-post указывает, куда отправить запрос.
    URL содержит {{meta.id}} и имя события 'increment'.
    hx-target указывает, какой элемент заменить.
    hx-swap="outerHTML" говорит заменить весь элемент целиком.
  -->
  <button
    hx-post="/_snap/event/{{meta.id}}/increment"
    hx-target="closest .counter-root"
    hx-swap="outerHTML"
  >+</button>
</div>

<!-- Сюда будут вставлены все изолированные стили -->
{{{styleTag}}}
```

### `style.css` (Одежда)

Опциональный файл, содержащий стандартный CSS. Движок `snap-off` автоматически парсит этот файл и добавляет к каждому селектору уникальный атрибут, чтобы гарантировать 100% стилистическую изоляцию и предотвратить конфликты стилей между компонентами.

**Пример (`style.css`):**
```css
/* Просто пишите обычный CSS. Движок сделает магию. */
.counter-root {
  border: 1px solid #ccc;
  padding: 1em;
  background-color: #f9f9f9;
}

.counter-root button:hover {
  background-color: #e0e0e0;
}
```
**Что получится на выходе:**
```css
.counter-root[snap-c-id="xyz123"] {
  border: 1px solid #ccc;
  /* ... */
}
.counter-root[snap-c-id="xyz123"] button:hover {
  /* ... */
}
```

### `component.stories.js` (Манекен)

Опциональный файл для интеграции с Dev Lab. Он описывает различные "истории" или состояния, в которых компонент может быть отрендерен. Подробнее об этом в документе [Dev Lab](./05-dev-lab.md).

---
**Следующий документ:** [3. Рендеринг и жизненный цикл](./03-rendering-and-lifecycle.md)