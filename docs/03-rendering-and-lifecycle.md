# Документация `snap-off`: 3. Рендеринг и жизненный цикл

Этот документ описывает динамические процессы в `snap-off`: как компонент появляется на свет, как он реагирует на события и как его жизненный цикл управляется сервером.

## 3.1. Первичный рендеринг: `snap.render()`

Все начинается с вызова функции `snap.render()` в одном из ваших серверных роутов. Этот вызов запускает четкую последовательность действий для создания нового экземпляра компонента.

**Пример вызова в `server.js`:**
```javascript
app.get('/', async (req, res) => {
  // Мы хотим отрендерить компонент 'user-profile' с props { userId: 123 }
  const profileHtml = await snap.render('user-profile', { userId: 123 }, req);
  res.send(profileHtml);
});
```

**Что происходит "под капотом":**

1.  **Загрузка компонента (`component-loader`):**
    -   `snap-off` находит директорию `src/components/user-profile/`.
    -   Он асинхронно читает файлы `component.json`, `handler.js`, `view.html` и `style.css`.
    -   Если компонент уже был загружен ранее, он мгновенно берется из кэша.

2.  **Создание состояния (`state-manager`):**
    -   Генерируется уникальный ID для этого экземпляра, например, `aB_cDeF1`.
    -   Вызывается функция `createState({ userId: 123 })` из `handler.js`.
    -   Результат (начальное состояние) сохраняется в `req.session` под ключом `aB_cDeF1`.

3.  **Обработка стилей (`style-engine`):**
    -   Движок стилей анализирует `props`. Если в них есть "Styling Props" (например, `backgroundColor: 'blue'`), он готовит инлайн-стили.
    -   Он берет содержимое `style.css`, парсит его и добавляет к каждому селектору уникальный атрибут `[snap-c-id="aB_cDeF1"]`, обеспечивая изоляцию.
    -   Все изолированные и динамические стили собираются в один блок, готовый для вставки в тег `<style>`.

4.  **Рендеринг шаблона (`renderer`):**
    -   `snap-off` берет шаблон `view.html`.
    -   Он передает в шаблонизатор Handlebars объект с данными: `state`, `props`, `meta` (включая `meta.id`), `styleAttr` и `styleTag`.
    -   Handlebars заменяет все плейсхолдеры `{{...}}` на реальные значения.

5.  **Возврат HTML:**
    -   Функция `snap.render()` возвращает готовую HTML-строку.
    -   Express отправляет этот HTML клиенту.

В результате браузер получает полностью готовый к отображению, стилизованный и интерактивный фрагмент HTML.

## 3.2. Жизненный цикл при событии

Когда пользователь взаимодействует с отрендеренным компонентом (например, нажимает на кнопку), запускается второй, не менее важный цикл.

**Кнопка в `view.html`:**
```html
<button hx-post="/_snap/event/aB_cDeF1/updateProfile">Сохранить</button>
```

**Что происходит "под капотом":**

1.  **Запрос от клиента:**
    -   HTMX отправляет `POST` запрос на `/snap/event/aB_cDeF1/updateProfile`.

2.  **Обработка на сервере (`event-handler`):**
    -   Middleware `snap.middleware` перехватывает этот запрос.
    -   Он парсит URL и извлекает:
        -   `instanceId`: `aB_cDeF1`
        -   `eventName`: `updateProfile`

3.  **Извлечение состояния (`state-manager`):**
    -   Движок обращается к `req.session` и по `instanceId` находит текущее состояние этого экземпляра компонента.

4.  **Загрузка компонента (`component-loader`):**
    -   По сохраненному имени компонента он мгновенно получает его определение из кэша.

5.  **Выполнение логики (`handler.js`):**
    -   Движок находит функцию `updateProfile` в объекте `events` из `handler.js`.
    -   Он вызывает `events.updateProfile(currentState, payload)`, где `payload` — это данные из тела запроса (если они есть).
    -   Обработчик возвращает **новый** объект состояния.

6.  **Обновление состояния (`state-manager`):**
    -   Новое состояние сохраняется в `req.session`, затирая старое для этого `instanceId`.

7.  **Перерисовка (`renderer`):**
    -   Вызывается функция `rerenderComponent`.
    -   Она использует то же определение компонента, но уже с **новым** состоянием из сессии.
    -   Процесс рендеринга повторяется: стили изолируются, шаблон наполняется данными.

8.  **Ответ клиенту:**
    -   Сервер отправляет свежесгенерированный HTML обратно клиенту. HTMX получает его и обновляет соответствующий элемент на странице.

## 3.3. Жизненный цикл WebSocket-обновления

Этот цикл самый простой и эффективный.

1.  **Инициация на сервере:**
    -   Ваша бизнес-логика решает, что нужно отправить обновление.
    -   Вы вызываете `snapSockets.broadcast({ html: '<div>Новое сообщение!</div>' })`.

2.  **Вещание (`websocket-server`):**
    -   WebSocket-сервер отправляет строку `'<div>Новое сообщение!</div>'` всем подключенным клиентам.

3.  **Прием на клиенте:**
    -   Расширение `ws.js` в браузере клиента получает эту строку.
    -   Оно находит на странице элемент с атрибутом `ws-swap="message"`.
    -   Оно вставляет полученный HTML внутрь этого элемента.

В этом цикле не задействованы ни состояние, ни `handler.js`, ни `renderer`. Это прямая "доставка" готового HTML от сервера к клиенту, что делает его невероятно быстрым.

---
**Следующий документ:** [4. Стилизация и Styling Props](./04-styling-and-props.md)